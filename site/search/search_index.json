{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>My name is Chris and I created this project as part of my directed study under Dr. Frank Wood in the Fall of 2025.</p>"},{"location":"#about-this-documentation","title":"About This Documentation","text":"<p>My goal of this technical report is to attempt to capture the 3 months I spent building this project such that if you were to start from nothing, you could probably do everything that I have done in the span of a week. I want to acknowledge that I cut some corners for the sake of speed.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>I am indebted to everyone on the PLAICraft project, who paved a lot of the way for this project to happen. I worked on PLAICraft for about 6 months, and I would say that the best way to describe my project is that it's a PLAICraft for anything.</p>"},{"location":"#what-to-expect","title":"What to Expect","text":"<p>I will try to keep these docs exciting by attempting to be funny. Sorry in advance. I am incredibly excited to dump the wealth of notes I have taken, and explain exactly how I overcame the various \"gotchas\" in building a scalable cloud framework for capturing training data for desktop agents.</p> <p>Let's get started.</p>"},{"location":"images-guide/","title":"How to Add Images in MkDocs","text":"<p>MkDocs makes it easy to add images to your documentation. Here's how:</p>"},{"location":"images-guide/#basic-image-syntax","title":"Basic Image Syntax","text":"<p>Use standard Markdown image syntax:</p> <pre><code>![Alt text](path/to/image.png)\n</code></pre> <p>Or with a title:</p> <pre><code>![Alt text](path/to/image.png \"Image title\")\n</code></pre>"},{"location":"images-guide/#image-organization","title":"Image Organization","text":""},{"location":"images-guide/#recommended-structure","title":"Recommended Structure","text":"<p>Create an <code>images</code> folder in your <code>docs</code> directory:</p> <pre><code>docs/\n  \u251c\u2500\u2500 index.md\n  \u251c\u2500\u2500 images/\n  \u2502   \u251c\u2500\u2500 screenshot1.png\n  \u2502   \u251c\u2500\u2500 diagram.svg\n  \u2502   \u2514\u2500\u2500 logo.jpg\n  \u2514\u2500\u2500 Introduction/\n      \u2514\u2500\u2500 overview.md\n</code></pre>"},{"location":"images-guide/#paths","title":"Paths","text":"<p>From the same directory: <pre><code>![Screenshot](images/screenshot.png)\n</code></pre></p> <p>From a subdirectory: <pre><code>![Diagram](../images/diagram.png)\n</code></pre></p> <p>From the root docs folder: <pre><code>![Logo](/images/logo.png)\n</code></pre></p>"},{"location":"images-guide/#examples","title":"Examples","text":""},{"location":"images-guide/#basic-image","title":"Basic Image","text":"<pre><code>![Architecture Diagram](images/architecture.png)\n</code></pre>"},{"location":"images-guide/#image-with-link","title":"Image with Link","text":"<pre><code>[![Click me](images/thumbnail.png)](images/full-size.png)\n</code></pre>"},{"location":"images-guide/#centered-image-using-html","title":"Centered Image (using HTML)","text":"<pre><code>&lt;p align=\"center\"&gt;\n  &lt;img src=\"images/logo.png\" alt=\"Logo\" width=\"200\"&gt;\n&lt;/p&gt;\n</code></pre>"},{"location":"images-guide/#image-with-caption-using-html","title":"Image with Caption (using HTML)","text":"<pre><code>&lt;figure&gt;\n  &lt;img src=\"images/diagram.png\" alt=\"System Architecture\"&gt;\n  &lt;figcaption&gt;Figure 1: System Architecture Overview&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre>"},{"location":"images-guide/#supported-formats","title":"Supported Formats","text":"<p>MkDocs supports all standard web image formats: - PNG - Best for screenshots, diagrams with text - JPG/JPEG - Best for photos - SVG - Best for scalable diagrams and logos - GIF - For animated images - WebP - Modern format with good compression</p>"},{"location":"images-guide/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive alt text - Important for accessibility</li> <li>Optimize images - Compress large images before adding them</li> <li>Use relative paths - Makes your docs portable</li> <li>Organize in folders - Keep images organized by topic</li> <li>Use SVG when possible - Scales perfectly at any size</li> </ol>"},{"location":"images-guide/#example-adding-an-image-to-your-docs","title":"Example: Adding an Image to Your Docs","text":"<ol> <li> <p>Create the images folder:    <pre><code>mkdir docs/images\n</code></pre></p> </li> <li> <p>Add your image file (e.g., <code>docs/images/architecture.png</code>)</p> </li> <li> <p>Reference it in your markdown:    <pre><code>![System Architecture](images/architecture.png)\n</code></pre></p> </li> <li> <p>The image will appear when you build or serve your docs!</p> </li> </ol>"},{"location":"images-guide/#troubleshooting","title":"Troubleshooting","text":"<p>Image not showing? - Check the path is correct (relative to the markdown file) - Make sure the image file exists - Check for typos in the filename - Use <code>/images/</code> (with leading slash) for paths from root</p> <p>Image too large? - Use HTML to resize: <code>&lt;img src=\"images/photo.jpg\" width=\"500\"&gt;</code> - Or compress the image file itself</p>"},{"location":"Introduction/amazon-web-services/","title":"Amazon Web Services","text":"<p>AWS was the cloud provider that I used, and from this point forward, I will not be using brand-agnostic terms. With that in mind, here are a few of the services and their jargon that you should know about:</p>"},{"location":"Introduction/amazon-web-services/#ec2","title":"EC2","text":"<p>These are Amazon's virtual machines. You pick the OS, the hardware, the storage, the security groups, the IAM roles. It's a computer in the cloud.</p>"},{"location":"Introduction/amazon-web-services/#ami","title":"AMI","text":"<p>If you take a snapshot of an EC2, it's like Amazon takes every byte exactly where it is at a given time and freezes it into an AMI. It is super easy to make one and then create new EC2's from it. Think of it as a saved file that you can clone infinitely.</p>"},{"location":"Introduction/amazon-web-services/#iam","title":"IAM","text":"<p>These are permissions in AWS. Wanna write to a database? You need IAM permissions for that. Wanna read a database? There's a SEPARATE IAM permission for that. If any services will interact with each other (and they will a whole damn lot), they need IAM permissions. Permissions are inside a Policy which is inside a Role.</p>"},{"location":"Introduction/amazon-web-services/#s3","title":"S3","text":"<p>Basically Google Drive. You can write to it via a library called <code>boto3</code>, which is basically AWS tools that lets you interact with AWS outside of AWS. The basic unit of S3 is a bucket.</p>"},{"location":"Introduction/amazon-web-services/#dynamodb","title":"DynamoDB","text":"<p>A database service. It's NoSQL, meaning that you don't interact with it via a query language like SQL. In my opinion, this just makes it easier to view / interact with than some of AWS's SQL solutions like RDS.</p>"},{"location":"Introduction/amazon-web-services/#lambda","title":"Lambda","text":"<p>Lambdas are sick. They're basically serverless and stateless chunks of code that you can trigger in various ways (e.g. EventBridge). If you want to upload a new hot dog recipe to your S3 and your DynamoDB, one lambda can do both. They're like spaghetti strands that make sure information flows through your application.</p>"},{"location":"Introduction/amazon-web-services/#api-gateway","title":"API Gateway","text":"<p>This is how I called Lambdas from the frontend. You set up an endpoint that your app can hit like <code>https://aws.gateway123/join/schedule</code> and when you hit it, you decide what it does. I had it invoke lambdas with whatever payload my frontend sent.</p> <p>Note: If I was hosting my domain on AWS, I would probably use something like Route 53, but I used Cloudflare. I'll get to that later.</p>"},{"location":"Introduction/jitsi-meet/","title":"Jitsi Meet","text":"<p>Jitsi itself is an open-source project containing several repositories. The only real important one for the sake of this project is Jitsi Meet. This is the main video conferencing application that has been extremely well-maintained and well-documented. It comes in a few forms via their docs, including downloading as a complete docker file that Just Works\u2122. However, you probably don't want that if, like me, you don't really understand Docker and its limitations.</p>"},{"location":"Introduction/jitsi-meet/#setup-advice","title":"Setup Advice","text":"<p>My advice: before even setting up a Jitsi server, have a purchased domain ready from a major provider like Cloudflare. Also, don't try to run peer-to-peer or locally. I managed to run my own Jitsi server from my own machine, but it requires access to your router so that you can enable port-forwarding ports. I probably spent two weekends trying to use a relay to access my server via STUN/TURN servers. Just skip all that, get AWS free tier, and install it on an EC2.</p> <p>Holy crap, the handbook actually has that exact advice. Too bad I didn't listen. But you can, and you should.</p>"},{"location":"Introduction/nice-dcv/","title":"NICE DCV","text":"<p>Amazon DCV (previously NICE DCV) is a remote desktop protocol (RDP). RDP lets you take remote control of someone else's computer, while having their screen streamed directly to you. The main app for doing this is literally just called Windows RDP. DCV costs nothing, it's like a package that unlocks extra functionality on EC2 instances.</p> <p>So why did Amazon acquire DCV for a bunch of money? Here are a few things that are special about DCV:</p> <ol> <li>Multi-user support: Several users can remote in at the same time, Windows RDP only allows one session</li> <li>Cross-platform: Supported on the three main operating systems (MacOS, Linux, Windows)</li> <li>High performance: DCV supports 4K and 60 FPS, and will compress the image quality in order to maintain low latency</li> <li>Dynamic resizing: DCV can resize the remote session based on the size of the end user's client</li> </ol> <p>All these things make DCV an interesting choice for companies that have expensive, highly customized workstations because they can simply remote into that machine. It also is good for gaming and is the remote desktop protocol that supports PLAICraft.</p>"},{"location":"Introduction/nice-dcv/#does-it-just-worktm","title":"Does it Just Work\u2122?","text":"<p>Like, almost. DCV itself is incredibly stable, but just be warned that if you don't have a valid SSL, you're SOL. Both Jitsi Meet and DCV use TCP/UDP for video streaming (rather than HTTP), and anything Websocket, WebRTC or UDP-based will basically reject a connection unless both sides have valid SSL certificates. SSL certificates are very easily generated from a domain provider like Cloudflare when you own a domain.</p> <p>Also, keep in mind that DCV is closed-source, and early on I tried to figure out how to separate inputs between multiple users in DCV, but I barely made a scratch.</p>"},{"location":"Introduction/open-world-agents/","title":"Open World Agents","text":"<p>PLAICraft, to capture multimodal training data, has a bespoke setup consisting of [[OBS]], a Minecraft mod package called Spigot, and then whatever middleware they used to pack it all in together. Open World Agents is trying to generalize that process for all desktop recording, which makes a ton of sense. It doesn't matter if the user interface is Minecraft, Excel or trading Memecoins; the inputs of screen, audio, mouse and keyboard ought to be the same.</p> <p>Actually, another win for DCV: it allows I/O devices, so bring your USB steering wheel.</p>"},{"location":"Introduction/open-world-agents/#ocap","title":"OCAP","text":"<p>The key component for this project from Open World Agents is called OCAP. OCAP captures full desktop interactions, and then writes it to two files:</p> <ul> <li>MCAP: MCAP is an open-source standard for time-aligned multimodal input files</li> <li>MKV: Just a standard video file type</li> </ul> <p>OCAP mainly relies on an impossibly large library called Gstreamer, which is basically just a ton of multimedia encoders. You can generally install from Gstreamer the same way that people install from a package manager like brew or pip. Open World Agents and OCAP use Anaconda, which as far as I know is a virtual environment and path manager, not unlike a python virtual environment. The main way you call it is via <code>conda</code> and you'll know that you have conda when you see <code>(base)</code> in your terminal.</p>"},{"location":"Introduction/open-world-agents/#does-ocap-just-worktm","title":"Does OCAP Just Work\u2122?","text":"<p>Well... I give them 7.5 / 10. I must accept responsibility as a developer who reads docs too fast (or not at all). But their docs are quite scattered, and they recently broke off OCAP into its own repository which confused me.</p> <p>The biggest issues are critical limitations with OCAP at the time of writing:</p> <ul> <li>It's Windows-only</li> <li>It requires an NVIDIA GPU</li> </ul> <p>This means that you have to:</p> <ul> <li>Request from your cloud provider access to NVIDIA GPUs (I requested 8 vCPUs from AWS, which corresponded to two <code>g4dn.xlarge</code> instances at a time)</li> <li>Spend about 5x more on compute</li> <li>Install the correct NVIDIA drivers on your virtual machine</li> <li>Probably increase the storage while you're at it</li> </ul> <p>I plan on making an open-source contribution to their project, because near the end of my directed study I was able to replace the NVIDIA encoder with a more standard <code>x264enc</code> software encoder. I hope that I can save you some grief. In the event that I was abducted or something, it's not hard. The encoder is hardcoded within the project and OCAP is open-source.</p>"},{"location":"Introduction/open-world-agents/#installation","title":"Installation","text":"<p>The last thing on OCAP for this section: I found that the commands in the docs straight up did not work. Here's what you should do: download the project onto your VM via GitHub, then in Powershell, run this command. This basically installs all the dependencies for the project as far as I know.</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"Introduction/overview/","title":"Introduction","text":"<p>(New drawing)</p> <p>This project is built on several fundamental components that work together to create a scalable cloud framework for capturing training data for desktop agents. Each component plays a crucial role in the overall system.</p>"},{"location":"Introduction/overview/#components-overview","title":"Components Overview","text":"<ul> <li>Jitsi Meet - Video conferencing infrastructure for real-time communication</li> <li>NICE DCV - Remote desktop protocol enabling multi-user access to virtual machines</li> <li>Open World Agents - Desktop interaction capture system using OCAP</li> <li>Windows - Operating system configuration and kiosk mode setup</li> <li>Amazon Web Services - Cloud infrastructure and services</li> </ul> <p>Each of these components has its own challenges and \"gotchas\" that I'll walk you through. Click on any component above to learn more about it, or continue reading below for a high-level overview.</p>"},{"location":"Introduction/overview/#how-they-work-together","title":"How They Work Together","text":"<p>The system architecture leverages these components to create a seamless experience:</p> <ol> <li>Jitsi Meet provides the video conferencing layer for real-time communication</li> <li>NICE DCV enables remote desktop access to powerful cloud workstations</li> <li>Open World Agents (OCAP) captures all desktop interactions in a standardized format</li> <li>Windows Server provides the operating system foundation with kiosk mode for secure, single-app sessions</li> <li>AWS hosts everything in the cloud, providing scalability and reliability</li> </ol> <p>This combination allows you to capture multimodal training data (screen, audio, mouse, keyboard) from any desktop application, whether it's Minecraft, Excel, or trading Memecoins, the inputs remain the same.</p>"},{"location":"Introduction/windows/","title":"Windows","text":"<p>This project will basically turn you into a system administrator. I used Windows Server 2022, which you should understand is not a full-feature Windows. There is no Microsoft Store. There are no AI features. Think of it this way: as an end user who has no computer science background, it's Windows Lite. But for someone looking to experiment with the OS, it should be everything you need.</p>"},{"location":"Introduction/windows/#user-setup","title":"User Setup","text":"<p>The most important part of my workflow on Windows was having two users:</p> <ul> <li>Administrator: Where I wrote code, set up Task Scheduler, messed with registries, etc.</li> <li>KioskUser: The end user</li> </ul>"},{"location":"Introduction/windows/#kiosk-mode","title":"Kiosk Mode","text":"<p>\"Kiosk\" refers to an umbrella term for single-app sessions in Windows. The burger menu screen at your local Wendy's? That's a kiosk.</p> <p>Normally, when a user logs into their desktop on Windows, it runs an executable called <code>explorer.exe</code>, which gives them the desktop GUI. If you replace that with your own executable, like <code>burger.exe</code>, congratulations, you just made a kiosk. The only thing the user has access to (not entirely true, see AppLocker below) is your app. If they <code>Alt + F4</code> and kill that process, they will only get a black screen.</p> <p>The main way that you configure a kiosk (other than creating a brand new user, which is straightforward) is via regedit, or Registry Edit. These are low-level instructions that the OS reads when booting up and when loading specific user profiles.</p> <p>\u26a0\ufe0f Warning: Do not go poking around here without a purpose because you could brick your whole virtual machine.</p>"},{"location":"Introduction/windows/#task-scheduler","title":"Task Scheduler","text":"<p>You'll also get familiar with Task Scheduler, which is a pretty awesome automation application that allows you to basically run any command on a certain trigger. There are pre-written triggers (e.g. at log on), but you can create custom triggers too (I never needed to).</p>"},{"location":"Introduction/windows/#applocker","title":"AppLocker","text":"<p>The last thing I'll mention now is AppLocker. AppLocker basically denies access to certain paths on a desktop, even ones that a user has access to by default. For example, you probably don't want your KioskUser accessing Task Manager, and you can lock that.</p> <p>It is NOT a keyboard logger, so users can still press <code>Ctrl + Alt + Delete</code> and get to the session menu that contains Task Manager.</p>"},{"location":"Phase%201/","title":"Phase 1: Setting up EC2, DCV and OCAP","text":""},{"location":"Phase%201/#overview","title":"Overview","text":"<p>The goal for this section is to use DCV to remote into your virtual machine running Windows, and have run OCAP successfully.</p>"},{"location":"Phase%201/#what-youll-learn","title":"What You'll Learn","text":"<p>This phase covers the complete setup process from creating your EC2 instance to running OCAP:</p> <ol> <li>EC2 - Launch and configure your Windows Server EC2 instance with security groups</li> <li>DCV - Connect via RDP and install NICE DCV for remote desktop</li> <li>OCAP - Install and configure OCAP for desktop capture</li> <li>Fork Discussion - Technical details about the custom OCAP fork</li> </ol>"},{"location":"Phase%201/#prerequisites","title":"Prerequisites","text":"<ul> <li>AWS account with EC2 access</li> <li>Basic familiarity with cloud computing concepts</li> <li>Windows Remote Desktop client (available on most operating systems)</li> </ul>"},{"location":"Phase%201/#expected-outcome","title":"Expected Outcome","text":"<p>By the end of this phase, you should have:</p> <ul> <li>A running Windows Server 2022 EC2 instance</li> <li>NICE DCV server installed and accessible</li> <li>OCAP successfully installed and running</li> <li>All necessary security groups configured</li> </ul> <p>Let's get started with EC2 Setup \u2192</p>"},{"location":"Phase%201/dcv/","title":"DCV Setup","text":"<p>NICE DCV (Desktop Cloud Visualization) is Amazon's high-performance remote desktop protocol. It's similar to Remote Desktop but optimized for cloud environments with better performance.</p>"},{"location":"Phase%201/dcv/#initial-connection-via-rdp","title":"Initial Connection via RDP","text":"<p>Before we can set up DCV, we need to connect to your Windows EC2 instance using Remote Desktop Protocol (RDP). This allows us to access the full Windows GUI and install software.</p>"},{"location":"Phase%201/dcv/#starting-your-instance","title":"Starting Your Instance","text":"<p>Start your EC2 instance from the EC2 dashboard if it's not already running.</p> <p></p>"},{"location":"Phase%201/dcv/#why-rdp-instead-of-ssh","title":"Why RDP Instead of SSH?","text":"<p>If you're familiar with SSH for Linux instances, you might wonder why we're using RDP. The key difference is that Windows servers have a full GUI, and we need to install software from the internet using a web browser\u2014something that's much easier with a graphical interface.</p> <p>Rather than installing packages via <code>curl</code> or package managers, we'll use the Windows GUI to download and install everything we need.</p>"},{"location":"Phase%201/dcv/#windows-remote-desktop-client","title":"Windows Remote Desktop Client","text":"<p>You'll need the Windows Remote Desktop app to connect. It's available on most operating systems:</p> <ul> <li>Mac: Available in the App Store</li> <li>Windows: Built-in Remote Desktop Connection</li> <li>Linux: Various clients available (Remmina, etc.)</li> </ul> <p></p> <p>Available Everywhere</p> <p>Windows Remote Desktop is available on your OS of choice. This will allow us to remote into our EC2 before we even have DCV installed.</p>"},{"location":"Phase%201/dcv/#getting-your-connection-details","title":"Getting Your Connection Details","text":""},{"location":"Phase%201/dcv/#public-ipv4-address","title":"Public IPv4 Address","text":"<p>When you launch your EC2 instance, AWS automatically provisions a public IPv4 address. This address is assigned on startup and may change if you stop and start the instance.</p> <p></p> <p>Dynamic IP Addresses</p> <p>The public IP address is provisioned automatically on startup and is basically random. We'll have a solution for accessing your EC2 via a static link in the future, but for now, grab the current public IP.</p>"},{"location":"Phase%201/dcv/#getting-rdp-connection-details","title":"Getting RDP Connection Details","text":"<p>Within the EC2 console, click the Connect button for your instance. Select the RDP Client option.</p> <p></p>"},{"location":"Phase%201/dcv/#logging-in","title":"Logging In","text":"<p>If you're using a default Windows AMI (which you should be), AWS will provide you with a password at the bottom of the Connect screen.</p> <p>Use these credentials to log in:</p> <ul> <li>Username: <code>Administrator</code></li> <li>Password: The password provided by AWS (you can change this later in Windows settings)</li> </ul> <p></p>"},{"location":"Phase%201/dcv/#youre-connected","title":"You're Connected!","text":"<p>Once logged in, you should see the Windows desktop.</p> <p></p> <p>Welcome! You are now in your remote computer.</p> <p>Performance Note</p> <p>If the framerate is poor, don't worry about that yet. You might be connected via TCP, which is slower than UDP for video streaming. We'll cover optimizations later (check Phase 6 - Optimizations).</p>"},{"location":"Phase%201/dcv/#installing-dcv-server","title":"Installing DCV Server","text":"<p>Now that you're connected to your Windows instance via RDP, we need to install the DCV Server on your EC2 instance.</p>"},{"location":"Phase%201/dcv/#download-dcv-server","title":"Download DCV Server","text":"<ol> <li>Open Microsoft Edge on your EC2 instance</li> <li>Navigate to: https://www.amazondcv.com/</li> <li>Download the DCV Server for Windows</li> <li>Run the installer with standard settings</li> </ol> <p>Installation Process</p> <p>The setup process is pretty straightforward\u2014similar to installing any Remote Desktop software. If you've used Remote Desktop before, the client will feel familiar.</p>"},{"location":"Phase%201/dcv/#additional-downloads","title":"Additional Downloads","text":"<p>Optional Component</p> <p>There's an additional component you can download from the DCV site. I'm not exactly sure what it does, and I didn't see a huge change after downloading it, but it could help down the road. Feel free to install it if you want.</p>"},{"location":"Phase%201/dcv/#installing-dcv-client-local-machine","title":"Installing DCV Client (Local Machine)","text":"<p>Download and install the DCV client on your local machine (not the EC2 instance). This is the application you'll use to connect to your EC2 instance.</p> <p>The client is available for: - Windows - macOS - Linux - Web browser</p>"},{"location":"Phase%201/dcv/#accessing-dcv","title":"Accessing DCV","text":"<p>There are three ways to access DCV:</p> <ol> <li>Browser Client - Access via web browser (no installation needed)</li> <li>Native Client - The desktop application you just downloaded</li> <li>SDK - Programmatic access (we'll use this later)</li> </ol>"},{"location":"Phase%201/dcv/#browser-access","title":"Browser Access","text":"<p>To access your EC2 via web browser, use your EC2's public DNS address with port 8443:</p> <pre><code>https://ec2-35-88-162-10.us-west-2.compute.amazonaws.com:8443\n</code></pre> <p>Replace the example DNS with your actual EC2 public DNS (found in the EC2 console).</p> <p>Default Port</p> <p>Port 8443 is the default port for DCV connections, which is why we configured it in the security group.</p>"},{"location":"Phase%201/dcv/#what-you-should-have-now","title":"What You Should Have Now","text":"<p>At this point, you should have:</p> <ul> <li>Successfully connected to your EC2 instance via RDP</li> <li>DCV Server installed on your EC2 instance</li> <li>DCV Client installed on your local machine</li> <li>Ability to connect to your EC2 via DCV (browser or native client)</li> </ul> <p>Next: OCAP Installation \u2192</p>"},{"location":"Phase%201/ec2/","title":"EC2 Setup","text":"<p>This guide walks you through setting up a Windows Server EC2 instance that will serve as your remote desktop environment.</p>"},{"location":"Phase%201/ec2/#launching-your-ec2-instance","title":"Launching Your EC2 Instance","text":"<p>Navigate to the EC2 service in the AWS Console and click Launch Instance.</p> <p></p>"},{"location":"Phase%201/ec2/#instance-configuration","title":"Instance Configuration","text":"<p>You have considerable flexibility in how you configure your EC2 instance. Here's what I recommend and why:</p>"},{"location":"Phase%201/ec2/#ami-selection","title":"AMI Selection","text":"<p>Microsoft Windows Server 2022 Base</p> <ul> <li>We need Windows because OCAP requires it</li> <li>Only Windows DCV supports webcam access</li> <li>Use the most recent Windows Server version available</li> </ul>"},{"location":"Phase%201/ec2/#instance-type","title":"Instance Type","text":"<p>t3.xlarge (4 vCPUs, 16 GB RAM)</p> <p>Instance Type Selection</p> <p>The T3 series is like picking Mario in Mario Kart\u2014kinda basic, but you can't go wrong with it. It's the most popular choice for general-purpose workloads.</p> <p>If you're on the free tier, use the largest instance type available to you. You may not even need 16GB RAM for your use case\u2014you can always adjust later once you're comfortable with EC2.</p>"},{"location":"Phase%201/ec2/#key-pair","title":"Key Pair","text":"<p>Create new key pair</p> <p>Key Pairs</p> <p>Key pairs provide an additional layer of security when accessing EC2 instances. You'll create the public/private key pair in your AWS account and keep the private key on your local machine.</p>"},{"location":"Phase%201/ec2/#storage","title":"Storage","text":"<p>Use default settings for now</p> <p>Storage Management</p> <p>You can always add more storage later if needed. I initially added storage for NVIDIA drivers, but it turned out to be unnecessary.</p>"},{"location":"Phase%201/ec2/#security-groups-configuration","title":"Security Groups Configuration","text":"<p>Security groups act as virtual firewalls that control traffic to your EC2 instances. Proper configuration is essential for both security and functionality.</p>"},{"location":"Phase%201/ec2/#security-group-best-practices","title":"Security Group Best Practices","text":"<p>Avoid This Mistake</p> <p></p> <p>Don't do this! The configuration shown above is messy and not recommended.</p> <p>You should ideally create a separate security group for each purpose. For example, if one EC2 is running your DCV session and another is running a Jitsi server, the ports you need are different.</p>"},{"location":"Phase%201/ec2/#required-security-group-rules","title":"Required Security Group Rules","text":"<p>Here are the ports you'll need to open for this setup:</p> Type Protocol Port Range Source Description RDP TCP <code>3389</code> <code>My IP</code> Initial Install &amp; Backup Access Custom TCP TCP <code>8443</code> <code>0.0.0.0/0</code> NICE DCV (Web/Client) Custom UDP UDP <code>8443</code> <code>0.0.0.0/0</code> NICE DCV (QUIC Support) Custom UDP UDP <code>10000</code> <code>0.0.0.0/0</code> Jitsi Meet (Media/VideoBridge) HTTP TCP <code>80</code> <code>0.0.0.0/0</code> Jitsi Meet (Web Access) HTTPS TCP <code>443</code> <code>0.0.0.0/0</code> Jitsi Meet (Web Access) SSH TCP <code>22</code> <code>My IP</code> SSH Access (Admin) <p>Source IP Configuration</p> <ul> <li>Use <code>My IP</code> for RDP and SSH to restrict access to your current IP address</li> <li>Use <code>0.0.0.0/0</code> for services that need to be publicly accessible (DCV, Jitsi)</li> <li>You can always tighten security later by restricting to specific IP ranges</li> </ul>"},{"location":"Phase%201/ec2/#port-explanations","title":"Port Explanations","text":"<ul> <li>3389 (RDP): Required for initial connection to Windows before DCV is set up</li> <li>8443 (DCV): Default port for NICE DCV connections</li> <li>10000 (Jitsi UDP): Required for Jitsi Meet media streaming</li> <li>80/443 (HTTP/HTTPS): Required for Jitsi Meet web access</li> <li>22 (SSH): Useful for administrative tasks (optional for Windows instances)</li> </ul>"},{"location":"Phase%201/ec2/#launch-the-instance","title":"Launch the Instance","text":"<p>Once you've configured all settings including the security group, click Launch Instance to create your EC2 instance.</p> <p>Next: DCV Setup \u2192</p>"},{"location":"Phase%201/fork-discussion/","title":"Fork Discussion","text":"<p>This document explains the customizations made to the OCAP fork used in this project.</p>"},{"location":"Phase%201/fork-discussion/#repository","title":"Repository","text":"<p>GitHub: https://github.com/shaundano/elephant-ocap</p>"},{"location":"Phase%201/fork-discussion/#why-use-this-fork","title":"Why Use This Fork?","text":"<p>The standard OCAP installation may not work directly on non-GPU EC2 instances. This fork includes several modifications that enable OCAP to run on standard EC2 instances and adds additional features.</p>"},{"location":"Phase%201/fork-discussion/#key-modifications","title":"Key Modifications","text":""},{"location":"Phase%201/fork-discussion/#1-non-gpu-encoder-support","title":"1. Non-GPU Encoder Support","text":"<p>What Changed: Swapped the NVIDIA encoder for a standard non-GPU encoder (<code>x264enc</code>)</p> <p>Why: This allows OCAP to run on non-GPU EC2 instances (like t3.xlarge)</p> <p>Location: <code>pipeline.py</code></p> <pre><code>screen_src |= \"t. ! queue ! d3d11download ! videoconvert ! video/x-raw,format=NV12 ! x264enc tune=zerolatency speed-preset=ultrafast ! h264parse ! queue ! mux.\"\n</code></pre> <p>This line determines the encoder used for video recording.</p>"},{"location":"Phase%201/fork-discussion/#2-microphone-audio-capture","title":"2. Microphone Audio Capture","text":"<p>What Changed: Added a second audio capture channel for microphone input</p> <p>Why: Allows recording both microphone and system audio as separate tracks</p> <p>Location: <code>pipeline.py</code></p> <pre><code>if record_mic:\n    src |= ElementFactory.wasapi2src(loopback=False) &gt;&gt; \"audioconvert ! avenc_aac ! queue ! mux.\"\n</code></pre> <p>The <code>wasapi2src</code> component is the same one used for recording system audio. The only difference between input and output audio is the <code>loopback</code> boolean parameter.</p> <p>Option Definition:</p> <pre><code>record_mic: Annotated[bool, typer.Option(help=\"Whether to record microphone input as separate audio track\")] = True,\n</code></pre> <p>The component is passed through setup and during the actual record function.</p>"},{"location":"Phase%201/fork-discussion/#3-process-id-pid-file-management","title":"3. Process ID (PID) File Management","text":"<p>What Changed: Added PID file writing and graceful termination support</p> <p>Why: Windows doesn't have a graceful <code>kill</code> command like Unix systems. Sending a <code>task kill</code> to OCAP can corrupt files. This implementation allows graceful termination via SIGINT (Ctrl+C) from external processes.</p> <p>Implementation: Based on this Stack Overflow discussion</p>"},{"location":"Phase%201/fork-discussion/#writing-the-pid","title":"Writing the PID","text":"<p>Location: <code>recorder.py</code></p> <pre><code>pid_file = Path(r\"C:\\scripts\\pid\\ocap.pid\")\npid_file.parent.mkdir(parents=True, exist_ok=True)\npid_file.write_text(str(os.getpid()))\n</code></pre> <p>Windows finds its PID and writes it to a static directory (<code>C:\\scripts\\pid\\</code>).</p>"},{"location":"Phase%201/fork-discussion/#reading-and-using-the-pid","title":"Reading and Using the PID","text":"<p>Location: <code>stop-ocap.py</code></p> <pre><code>try:\n    with open(PID_FILE, \"r\") as f:\n        pid = int(f.read().strip())\n</code></pre> <p>The program reads <code>ocap.pid</code> and gets the process ID.</p>"},{"location":"Phase%201/fork-discussion/#sending-sigint","title":"Sending SIGINT","text":"<p>Location: <code>stop-ocap.py</code></p> <pre><code>if not kernel32.GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0):\n    print(f\"Failed to send Ctrl+C event. Error: {ctypes.get_last_error()}\")\nelse:\n    print(\"Successfully sent Ctrl+C signal.\")\n</code></pre> <ul> <li><code>kernel32</code> is a Windows system library that provides low-level API functions</li> <li><code>GenerateConsoleCtrlEvent</code> sends the SIGINT signal</li> <li>The SIGINT is defined as Ctrl+C, and <code>0</code> means it targets the entire group of processes attached to the console</li> </ul>"},{"location":"Phase%201/fork-discussion/#cleanup","title":"Cleanup","text":"<p>Location: <code>recorder.py</code></p> <pre><code>finally:\n    pid_file.unlink(missing_ok=True)\n</code></pre> <p>When OCAP wraps up, it deletes the PID file.</p>"},{"location":"Phase%201/fork-discussion/#pid-management-flow","title":"PID Management Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OCAP Starts    \u2502\n\u2502  Writes PID     \u2502\n\u2502  to file        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  External       \u2502\n\u2502  Process reads  \u2502\n\u2502  PID file       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Send SIGINT    \u2502\n\u2502  (Ctrl+C)       \u2502\n\u2502  via kernel32   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  OCAP gracefully\u2502\n\u2502  terminates     \u2502\n\u2502  Deletes PID    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"Phase%201/fork-discussion/#benefits-of-using-this-fork","title":"Benefits of Using This Fork","text":"<ol> <li>Compatibility: Works on standard (non-GPU) EC2 instances</li> <li>Flexibility: Includes microphone capture option</li> <li>Reliability: Proper graceful shutdown prevents file corruption</li> <li>Visibility: You can see and modify dependencies in <code>pyproject.toml</code></li> <li>Control: You're not dependent on the latest version from PyPI</li> </ol> <p>Congratulations! You've completed Phase 1. You should now have a fully functional setup with EC2, DCV, and OCAP running.</p>"},{"location":"Phase%201/ocap/","title":"OCAP Installation","text":"<p>OCAP (Open-World Agent Capture) is the desktop interaction capture system we'll use to record screen, audio, and input data. This section covers the installation and configuration process.</p>"},{"location":"Phase%201/ocap/#directory-structure","title":"Directory Structure","text":"<p>First, set up the required directory structure on your EC2 at the <code>C:\\</code> root level:</p> <pre><code>C:\\scripts\\\n\u251c\u2500\u2500 pid\\\n\u2502   \u2514\u2500\u2500 (PID files will be written here - see fork documentation)\n\u251c\u2500\u2500 temp_recordings\\\n\u2502   \u2514\u2500\u2500 (OCAP will write recordings here)\n\u2514\u2500\u2500 (scripts go here)\n\nC:\\projects\\\n\u2514\u2500\u2500 (OCAP repository will go here)\n</code></pre>"},{"location":"Phase%201/ocap/#downloading-the-ocap-fork","title":"Downloading the OCAP Fork","text":"<p>Download the custom OCAP fork as a ZIP file:</p> <p>Repository: https://github.com/shaundano/elephant-ocap</p> <p>Extract the ZIP file into the <code>C:\\projects\\</code> folder.</p> <p>Why Use This Fork?</p> <p>This fork includes several customizations that allow it to run on non-GPU EC2 instances and includes additional features like microphone capture. See the Fork Discussion for technical details.</p>"},{"location":"Phase%201/ocap/#installing-miniconda3","title":"Installing Miniconda3","text":"<p>OCAP requires Conda as a package manager (used by Open World Agents). Install Miniconda3 via PowerShell:</p> <pre><code>Invoke-WebRequest -Uri \"https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe\" -OutFile \".\\Downloads\\Miniconda3-latest-Windows-x86_64.exe\"\n</code></pre> <p>Run the installer. If given the option to install for all users, accept it.</p> <p>Installation Complete</p> <p>Once installed, you should see <code>(base)</code> in your PowerShell prompt, indicating that Conda is active.</p>"},{"location":"Phase%201/ocap/#creating-the-conda-environment","title":"Creating the Conda Environment","text":"<p>Create a new Conda environment for OCAP:</p> <pre><code>conda create -n ocap-env python=3.14\n</code></pre> <p>Activate the environment:</p> <pre><code>conda activate ocap-env\n</code></pre> <p>You should now see <code>(ocap-env)</code> in your terminal prompt.</p>"},{"location":"Phase%201/ocap/#installing-ocap","title":"Installing OCAP","text":"<p>Navigate to the OCAP project folder in PowerShell, then install it in editable mode:</p> <pre><code>pip install -e .\n</code></pre> <p>Editable Mode</p> <p>The <code>-e</code> flag installs in editable mode, which is like debug mode or hot refresh. If dependencies change in the Python project, it should automatically react. The dependencies are defined in <code>pyproject.toml</code>.</p>"},{"location":"Phase%201/ocap/#installing-gstreamer-dependencies","title":"Installing GStreamer Dependencies","text":"<p>Follow the official OCAP documentation and install GStreamer dependencies:</p> <pre><code># Install GStreamer dependencies first (for video recording)\nconda install open-world-agents::gstreamer-bundle\n\n# Install ocap\npip install ocap\n</code></pre>"},{"location":"Phase%201/ocap/#running-ocap","title":"Running OCAP","text":"<p>You should now be ready to run OCAP. Execute:</p> <pre><code>ocap my-recording\n</code></pre> <p>This will write files to the default path, which is <code>C:\\</code>.</p>"},{"location":"Phase%201/ocap/#success-indicators","title":"Success Indicators","text":"<p>If everything is working correctly, you should see output similar to:</p> <p> </p>"},{"location":"Phase%201/ocap/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Phase%201/ocap/#common-issues","title":"Common Issues","text":"<p>Don't Give Up!</p> <p>Getting OCAP to run was one of the hardest parts of this project to debug. Once it worked, I didn't even really understand why it started working.</p>"},{"location":"Phase%201/ocap/#environment-activation","title":"Environment Activation","text":"<p>Make sure your Conda environment is activated. You should see <code>(ocap-env)</code> on your terminal line.</p>"},{"location":"Phase%201/ocap/#missing-gstreamer-components","title":"Missing GStreamer Components","text":"<p>Error: <code>no module 'gi' found</code></p> <p>OCAP uses many different GStreamer components, and sometimes they'll be missing. Try:</p> <ol> <li>Re-installing the GStreamer plugins from open-world-agents</li> <li>Adding the <code>conda-forge</code> channel (should be enabled by default, but sometimes it isn't):</li> </ol> <pre><code>conda config --add channels conda-forge\n</code></pre>"},{"location":"Phase%201/ocap/#why-use-the-fork-instead-of-pip-install","title":"Why Use the Fork Instead of pip install?","text":"<p>By downloading the project directly onto your EC2, you're able to rely on your own local repository rather than <code>pip install ocap</code>, which uses the most recent version. This gives you visibility into the dependencies you need in <code>pyproject.toml</code> and allows you to customize the code if needed.</p> <p>Next: Fork Discussion \u2192</p>"}]}